---
title: 3.1.34
tags: Searching
date: 2019-03-10 12:55:51
---

# 题目

3.1.34
Zipf 法则。
用命中第 i 小的键的概率为 1/(iHN) 的分布重新完成上一道练习，
其中 Hn 为调和级数（请见表 1.4.6）。
这种分布被称为 Zipf 法则。
比较前移编码和上一道练习中的在特定分布下的最优安排，
该安排将所有键按升序排列（即按照它们的期望频率的降序排列）。

# 解答

在上一题的基础上进行修改即可，链接：{% post_link 3.1.33 %}。

调和级数 $ H_n = 1+\frac{1}{2}+\frac{1}{3} + \cdots+\frac{1}{n} $ 。
查询数组变为前 1/2 为 `key[0]`，随后的 1/3 为 `key[1]`，以此类推。
和上一题中的序列进行比较即可，注意删除最后的打乱步骤。

实验结果如下：
![](./1.png)



# 代码

首先建立一个数组计算调和级数，就像这样：

```csharp
// 调和级数
double[] harmonicNumber = new double[1000 * (int)Math.Pow(10, 4)];
harmonicNumber[0] = 1;
for (int i = 1; i < harmonicNumber.Length; i++)
{
    harmonicNumber[i] = harmonicNumber[i - 1] + 1 / (i + 1);
}
```

然后修改构造查询的代码：

```csharp
// 构造查询
Array.Sort(keys);
string[] queryZipf = new string[10 * n];
int queryIndex = 0, keyIndex = 0;
while (queryIndex < queryZipf.Length)
{
    int searchTimes = (int)Math.Ceiling(queryZipf.Length / (harmonicNumber[keyIndex + 1] * (i + 1)));

    for (int j = 0; j < searchTimes && queryIndex < queryZipf.Length; j++)
    {
        queryZipf[queryIndex++] = keys[keyIndex];
    }
    keyIndex++;
}
```

# 另请参阅

[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)